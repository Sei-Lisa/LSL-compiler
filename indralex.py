#!/usr/bin/env python

# indralex.py - This is a LSL2dfg.py output module generating constants for the indra.l viewer file.
#
# (C) Copyright 2017 Sei Lisa.
# Sei Lisa is the author's username in the Second Life online virtual world.
#
# This file is part of LSL2 Derived Files Generator.
#
#    LSL2 Derived Files Generator is free software: you can redistribute it
#    and/or modify it under the terms of the GNU Lesser General Public License
#    as published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    LSL2 Derived Files Generator is distributed in the hope that it will be
#    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with LSL2 Derived Files Generator. If not, see
#    <http://www.gnu.org/licenses/>.
#
# Second Life is a trademark of Linden Research, Inc.


# Input file should contain lines like:
#     <<< XXX KEYWORDS version >>>            to insert the version comment
#     <<< XXX KEYWORDS integer_constants >>>  to insert the integer constants
#     <<< XXX KEYWORDS string_constants >>>   to insert the string constants
#     <<< XXX KEYWORDS fp_constants >>>       to insert the float constants
#
# (XXX is the tag parameter, default is empty)


import sys

def output(document, defaultdescs, databaseversion, infilename, outfilename, lang, tag):

  version = "0.0.20140602000"

  iconstants = []
  sconstants = []
  fconstants = []

  for element in document:
    if element["cat"] == "constant":
      if element["type"] == "integer" and element["name"] not in ('TRUE','FALSE'):
        iconstants.append(element)
      elif element["type"] == "string":
        sconstants.append(element)
      elif element["type"] == "float":
        fconstants.append(element)

  if infilename is not None:
    inf = open(infilename, "rb")
  else:
    inf = sys.stdin

  try:
    inputlines = inf.readlines()

  finally:
    if infilename is not None:
      inf.close()

  if outfilename is not None:
    outf = open(outfilename, "wb")
  else:
    outf = sys.stdout

  try:

    for line in inputlines:
      if line.startswith(("<<< %s KEYWORDS version >>>" % tag).encode('utf8')):
        outf.write((" /* Generated by LSL2 Derived Files Generator. Database version: %s; output module version: %s */\n"
          % (databaseversion, version)).encode('utf8'))

      elif line.startswith(("<<< %s KEYWORDS integer_constants >>>" % tag).encode('utf8')):
        for element in iconstants:
          outf.write(('"%s" { count(); yylval.ival = %s; return(INTEGER_CONSTANT); }\n' % (element['name'], element['value'])).encode('utf8'))

      elif line.startswith(("<<< %s KEYWORDS fp_constants >>>" % tag).encode('utf8')):
        for element in fconstants:
          outf.write(('"%s" { count(); yylval.fval = %s; return(FP_CONSTANT); }\n' % (element['name'], element['value'])).encode('utf8'))

      elif line.startswith(("<<< %s KEYWORDS string_constants >>>" % tag).encode('utf8')):
        for element in sconstants:
          try:
            val = element['value'].encode('utf8').encode('string-escape')
          except:
            # Python 3
            val = element['value'].encode('utf8')
            val = val.replace(b'\\', b'\\\\').replace(b'\n', b'\\n').replace(b'"', b'\\"')
            for c in range(32):
              val = val.replace(chr(c).encode('latin1'), b'\\x'+hex(c)[2:].zfill(2).encode('utf8'))
            for c in range(129):
              val = val.replace(chr(c+127).encode('latin1'), b'\\x'+hex(c+127)[2:].zfill(2).encode('utf8'))
            #val = val.decode('utf8')

          outf.write(('"%s" {  yylval.sval = new char[%d]; strcpy(yylval.sval, "%s"); return(STRING_CONSTANT); }\n' % (element['name'], len(element['value'].encode('utf8'))+1, val.decode('utf8'))).encode('utf8'))

      else:
        outf.write(line)

  finally:
    if outfilename is not None:
      outf.close()


pass
